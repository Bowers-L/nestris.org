import { RNG } from "./rng";
import { TetrominoType } from "../tetromino-type";

/**
 * A class that generates Tetromino pieces based on a given seed.
 * It implements the RNGGym algorithm from the Python implementation.
 */
export class GymRNG extends RNG {
    private seed: number;
    private cnt: number;
    private iters: number;
    private prev: number;

    /**
     * Generate a random seed character from 0 to F.
     * @param zeroAllowed - Whether 0 is allowed as a seed character.
     * @returns A random seed character.
     */
    private static generateSeedChar(zeroAllowed: boolean): string {
        if (zeroAllowed) return Math.floor(Math.random() * 16).toString(16).toUpperCase();
        return Math.floor(Math.random() * 15 + 1).toString(16).toUpperCase();
    }

    /**
     * Generate a random seed character.
     * @returns A random seed string that does not have 00 in the first two bytes.
     */
    static generateRandomSeed(): string {
        let seed: string = "";
        for (let i = 0; i < 6; i++) {
            seed += GymRNG.generateSeedChar(i > 1);
        }
        return seed;
    }

    /**
     * Generate a random seed. Seed cannot have 00 in the first two bytes.
     */
    static fromRandomSeed(): GymRNG {
        return new GymRNG(GymRNG.generateRandomSeed());
    }

    /**
     * Creates an instance of TetrominoRNG.
     * @param seedStr - A hexadecimal string representing the seed (e.g., "04A825").
     */
    constructor(private readonly seedStr: string) {
        super();
        const seed = parseInt(seedStr, 16);
        this.prev = -1;
        this.seed = (seed >> 8) & 0xffff;
        this.cnt = seed & 0xff;
        this.iters = this.cnt >> 4;
        if (this.iters === 0) this.iters = 16;
        this.iters += 3;
    }

    /**
     * Creates a copy of the current RNG.
     * @returns A copy of the current RNG.
     */
    override copy(): GymRNG {
        const copy = new GymRNG(this.seedStr);
        copy.seed = this.seed;
        copy.cnt = this.cnt;
        copy.iters = this.iters;
        copy.prev = this.prev;
        return copy;
    }

    /**
     * Advances the internal state of the RNG.
     */
    private advance(): void {
        const bit = ((this.seed >> 1) ^ (this.seed >> 9)) & 1;
        this.seed = (this.seed >> 1) | (bit << 15);
    }

    /**
     * Get the string representation of the seed.
     */
    public getSeedString(): string {
        return this.seedStr;
    }

    /**
     * Generates the next Tetromino piece.
     * @returns The type of the next Tetromino piece.
     */
    public override getNextPiece(): TetrominoType {
        for (let i = 0; i < this.iters; i++) this.advance();
        this.cnt = (this.cnt + 1) & 255;
        let ind = ((this.seed >> 8) + this.cnt) & 7;
        if (ind === 7 || ind === this.prev) {
            this.advance();
            const prevIndex = this.prev < 0 ? 8 + this.prev : this.prev;
            const options = [2,7,8,10,11,14,18,0];
            ind = (((this.seed >> 8) & 7) + options[prevIndex]) % 7;
        }
        this.prev = ind;
        
        // Convert the algorithm's output to TetrominoType
        return this.convertToTetrominoType(ind);
    }

    /**
     * Converts the algorithm's output to the corresponding TetrominoType.
     * @param index - The index generated by the algorithm.
     * @returns The corresponding TetrominoType.
     */
    private convertToTetrominoType(index: number): TetrominoType {

        if (index < 0 || index > 7) throw new Error("Invalid index");

        const conversion: TetrominoType[] = [
            TetrominoType.T_TYPE,
            TetrominoType.J_TYPE,
            TetrominoType.Z_TYPE,
            TetrominoType.O_TYPE,
            TetrominoType.S_TYPE,
            TetrominoType.L_TYPE,
            TetrominoType.I_TYPE
        ];
        return conversion[index];
    }
}